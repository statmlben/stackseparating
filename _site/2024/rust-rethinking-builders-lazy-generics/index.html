<!DOCTYPE html>
<html>
  <head>
    <title>Rethinking Builders... with Lazy Generics – Stack Separating – There is nothing more practical than a good theory</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="While using compile-time builder generator crates, I realized that I had run into
a niche problem that required lot more flexibility with generic structs and 
functions than I was getting. If you like, follow me down a rabbit hole 
and explore the builder pattern from a very generic-centric perspective.
" />
    <meta property="og:description" content="While using compile-time builder generator crates, I realized that I had run into
a niche problem that required lot more flexibility with generic structs and 
functions than I was getting. If you like, follow me down a rabbit hole 
and explore the builder pattern from a very generic-centric perspective.
" />
    
    <meta name="author" content="Stack Separating
" />

    
    <meta property="og:title" content="Rethinking Builders… with Lazy Generics
" />
    <meta property="twitter:title" content="Rethinking Builders… with Lazy Generics
" />
    

    
    <meta property="og:image" content="https://raw.githubusercontent.com/geo-ant/blog/master/images/og/rethinking-builders.png" />
    <meta name="twitter:card" content="summary_large_image" />
    


    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/blog/style.css" />
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="alternate" type="application/rss+xml" title="Stack Separating - There is nothing more practical than a good theory" href="/blog/feed.xml" />
    <!--Google fonts: See this article for changing fonts: http://sebrink.de/Google-Webfonts-for-my-Jekyll/ -->
    <!-- <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Code+Pro|Vollkorn+SC|Vollkorn:400,400i&display=swap" rel="stylesheet"> -->
    <!--
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,500;1,500&family=Lato:wght@700;900&family=Source+Code+Pro:wght@500&family=Dela+Gothic+One&family=Cormorant+Garamond:ital,wght@1,300;1,400&display=swap" rel="stylesheet">     
    -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Dela+Gothic+One&family=JetBrains+Mono&family=Lato:wght@700&family=Marcellus&family=Vollkorn:ital@1&display=swap" rel="stylesheet">
    <!-- Shortcut Icon / Favicon-->
    <!-- <link rel="shortcut icon" type="image/png" href="/blog/images/favicon-196x196.png">
    <link rel="shortcut icon" sizes="196x196" href="/blog/images/favicon-196x196.png"> -->


    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <!-- <a href="/blog/" class="site-avatar"><img src="" /></a> -->

          <div class="site-info">
            <h1 class="site-name"><a href="/blog/"><p>Stack Separating</p>
</a></h1>
            <p class="site-description"><p>There is nothing more practical than a good theory</p>
</p>
          </div>

          <nav>
            <!-- <a href="/blog/">Recent</a> -->
            <!-- <a href="https://ko-fi.com/geoant">Buy &#x2615;</a> -->
            <a href="/blog/archive">Date</a>
            <a href="/blog/tags">Tag</a>
            <a href="/blog/about">About</a>
            <!-- <a href="/blog/feed.xml">Feed</a> -->
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1 class="page-title"><p>Rethinking Builders… with Lazy Generics</p>
</h1>
  

  <!-- the support banner-->
  <div class="date" style="display: flex; align-items: flex-start; justify-content: space-between;">
      <!-- Left: Banner Image -->
      <!-- <a href="https://ko-fi.com/geoant" target="_blank" title="Buy me a coffee :)">
          <img src="https://raw.githubusercontent.com/geo-ant/user-content/refs/heads/main/ko-fi-support-blue.svg" 
               alt="Banner Image" style="max-width: 190px; height: auto; margin-right: 20px;">
      </a> -->
      
      <div style="text-align: right;">
          Posted 2024-10-11 
      </div>
  </div>

  

  <div class="entry">
    <p>While using compile-time builder generator crates, I realized that I had run into
a niche problem that required lot more flexibility with generic structs and 
functions than I was getting. If you like, follow me down a rabbit hole 
and explore the builder pattern from a very generic-centric perspective.</p>

<h1 id="intro-to-builders">Intro To Builders</h1>

<p>The <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">builder pattern</a>
in Rust is so popular that there are a lot of crates that allow us to avoid
the boilerplate of generating the builders ourselves. Probably you’re already
familiar with the builder pattern and at least one crate that allows you to automatically
derive a compile-time verified builder for structs.</p>

<p>Here’s a highly <code class="language-plaintext highlighter-rouge">#[non-exhaustive]</code> list comprising these
kind of crates and their taglines on crates.io, ordered in descending order by total
number of downloads at the time of writing:</p>

<ul>
  <li><a href="https://crates.io/crates/typed-builder"><code class="language-plaintext highlighter-rouge">typed_builder</code></a> (ver <code class="language-plaintext highlighter-rouge">0.20.0</code>) “Compile-time type-checked builder derive”</li>
  <li><a href="https://crates.io/crates/buildstructor"><code class="language-plaintext highlighter-rouge">buildstructor</code></a> (ver <code class="language-plaintext highlighter-rouge">0.5.4</code>) “[…] derive a builder from a constructor function.”</li>
  <li><a href="https://crates.io/crates/bon"><code class="language-plaintext highlighter-rouge">bon</code></a> (ver <code class="language-plaintext highlighter-rouge">2.3.0</code>) “Generate builders for everything!”</li>
  <li><a href="https://crates.io/crates/const_typed_builder"><code class="language-plaintext highlighter-rouge">const_typed_builder</code></a> (ver. <code class="language-plaintext highlighter-rouge">0.3.0</code>) “Compile-time type-checked builder derive using const generics”</li>
  <li><a href="https://crates.io/crates/typestate-builder"><code class="language-plaintext highlighter-rouge">typestate_builder</code></a> (ver <code class="language-plaintext highlighter-rouge">0.1.1</code>) “[…] combines <code class="language-plaintext highlighter-rouge">Typestate</code> and <code class="language-plaintext highlighter-rouge">Builder</code> patterns”</li>
</ul>

<p>Note, that I gave the current crate versions in brackets, at the time of writing.
So, when I reference those crates, it’ll be based on these particular
versions. All of those crates are great, with <code class="language-plaintext highlighter-rouge">bon</code> and <code class="language-plaintext highlighter-rouge">typed_builder</code> being my personal
favorites and also among the most widely used. All these crates generate compile-time validated builders,
so they will give errors <em>at compile time</em> when you forget to set a mandatory field<sup id="fnref:runtime-builders" role="doc-noteref"><a href="#fn:runtime-builders" class="footnote" rel="footnote">1</a></sup>.
The <code class="language-plaintext highlighter-rouge">typestate_builder</code> crate is an honorable mention here, that I stumbled upon after
doing the proof-of-concept implementation presented in this article. At the time
of writing it’s very young and incomplete, but it’s different from the other mentioned crates
in some important details that –I believe– would enable it to implement
the ideas presented in this article.</p>

<p>The core functionality in all of those crates lies in their ability to generate
builders for structs<sup id="fnref:bon-core" role="doc-noteref"><a href="#fn:bon-core" class="footnote" rel="footnote">2</a></sup>. If you’ve never used builders, this is best
explained with an example.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(bon::Builder)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Foo</span><span class="o">&lt;</span><span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">first</span><span class="p">:</span> <span class="n">S</span><span class="p">,</span>
    <span class="n">second</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// foo1: Foo&lt;usize,f32&gt;</span>
    <span class="k">let</span> <span class="n">foo1</span> <span class="o">=</span> <span class="nn">Foo</span><span class="p">::</span><span class="nf">builder</span><span class="p">()</span>
                <span class="c1">// build order is</span>
                <span class="c1">// arbitrary</span>
                <span class="nf">.second</span><span class="p">(</span><span class="mf">2f32</span><span class="p">)</span>
                <span class="nf">.first</span><span class="p">(</span><span class="mi">1usize</span><span class="p">)</span>
                <span class="nf">.build</span><span class="p">();</span>
                
    <span class="c1">// ⚡ but this will not compile</span>
    <span class="c1">// ⚡ because we have not provided</span>
    <span class="c1">// ⚡ values for all fields</span>
    <span class="c1">// ⭐ this is a deliberate feature</span>
    <span class="k">let</span> <span class="n">foo2</span> <span class="o">=</span> <span class="nn">Foo</span><span class="p">::</span><span class="nf">builder</span><span class="p">()</span>
                    <span class="nf">.first</span><span class="p">(</span><span class="mf">1f32</span><span class="p">)</span>
                    <span class="c1">//⚡ forgot second</span>
                    <span class="nf">.build</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This example uses <code class="language-plaintext highlighter-rouge">bon</code>, but it will work –with minimal modifications– with
all the other mentioned crates<sup id="fnref:typed-builder-generics" role="doc-noteref"><a href="#fn:typed-builder-generics" class="footnote" rel="footnote">3</a></sup>. There’s much more that all these crates can do
for you and it’s well worth checking out<sup id="fnref:builder-capabilities" role="doc-noteref"><a href="#fn:builder-capabilities" class="footnote" rel="footnote">4</a></sup>. But now let’s
take a look at something that none of them can do, at least I wasn’t able to make them<sup id="fnref:tried-this" role="doc-noteref"><a href="#fn:tried-this" class="footnote" rel="footnote">5</a></sup>.</p>

<h1 id="problem-statement-lazy-generics">Problem Statement: Lazy Generics</h1>

<p>Let’s first look at piece of code that <em>does not</em> compile using any of the builder
crates mentioned above. Afterwards we’ll discuss what that code might be useful
for. Say we have a runtime boolean condition <code class="language-plaintext highlighter-rouge">cond</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// (1)</span>
<span class="k">let</span> <span class="n">builder</span> <span class="o">=</span> <span class="nn">Foo</span><span class="p">::</span><span class="nf">builder</span><span class="p">()</span><span class="nf">.first</span><span class="p">(</span><span class="mf">1.337f32</span><span class="p">);</span>
<span class="k">if</span> <span class="n">cond</span> <span class="p">{</span>
    <span class="c1">// (2)</span>
    <span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">builder</span><span class="nf">.second</span><span class="p">(</span><span class="mi">1usize</span><span class="p">)</span><span class="nf">.build</span><span class="p">();</span>
    <span class="c1">// use foo of type Foo&lt;f32,usize&gt;</span>
    <span class="c1">// ...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// (3)</span>
    <span class="c1">// ⚡ this does not compile</span>
    <span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">builder</span><span class="nf">.second</span><span class="p">(</span><span class="o">&amp;</span><span class="s">"hi"</span><span class="p">)</span><span class="nf">.build</span><span class="p">();</span>
    <span class="c1">// use foo of type Foo&lt;f32,&amp;str&gt;</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>
<p>In essence what I try to do is branch the builder on a runtime condition. Both
branches take the same argument for <code class="language-plaintext highlighter-rouge">first</code>, but different arguments for <code class="language-plaintext highlighter-rouge">second</code>.
Not only different arguments, but arguments of different <em>types</em>. This won’t compile
with any of the crates I tested; <a href="https://github.com/geo-ant/builder-experiments/blob/main/src/crosschecks.rs">here</a>
is a link to a repo that shows what I tried.</p>

<p>The reason this doesn’t work is, that the <code class="language-plaintext highlighter-rouge">Foo::builder()</code> function returns a builder
<code class="language-plaintext highlighter-rouge">FooBuilder&lt;S,T,Internal&gt;</code> that has the same <code class="language-plaintext highlighter-rouge">S</code> and <code class="language-plaintext highlighter-rouge">T</code> generic parameters as the generic
type <code class="language-plaintext highlighter-rouge">Foo&lt;S,T&gt;</code> and then some additional internal parameters<sup id="fnref:state-params" role="doc-noteref"><a href="#fn:state-params" class="footnote" rel="footnote">6</a></sup><sup>,</sup><sup id="fnref:typestate-builder" role="doc-noteref"><a href="#fn:typestate-builder" class="footnote" rel="footnote">7</a></sup>. At 
① the type <code class="language-plaintext highlighter-rouge">S</code> of <code class="language-plaintext highlighter-rouge">FooBuilder</code> gets deduced to <code class="language-plaintext highlighter-rouge">f32</code>, which is what we want. However, 
at ② the type <code class="language-plaintext highlighter-rouge">T</code> of <code class="language-plaintext highlighter-rouge">builder</code> gets deduced to <code class="language-plaintext highlighter-rouge">usize</code>. That
fixes the type of <code class="language-plaintext highlighter-rouge">builder</code> to <code class="language-plaintext highlighter-rouge">FooBuilder&lt;f32,usize,...&gt;</code>, and that makes
it a compilation error to pass a <code class="language-plaintext highlighter-rouge">&amp;str</code> in ③. If we had passed a different
value of type <code class="language-plaintext highlighter-rouge">usize</code> that would, of course, have been fine. There are many advantages
that come with this strong type deduction behavior and truth be told, I think
it’s the correct default to have.</p>

<p>But wouldn’t it also be cool if the code above had just worked? In a way, 
I want to avoid this eager evaluation of generics that is the root of my problem
and make the evaluation more <em>lazy</em>. Just because I want to pass a <code class="language-plaintext highlighter-rouge">usize</code> to
<code class="language-plaintext highlighter-rouge">second(...)</code> in ②, doesn’t mean I want to be forced to pass the 
same <em>type</em> in ③. This is what I mean with <em>lazy generics</em>. I feel 
the eager/lazy wording is not quite what I want to express, but I couldn’t
come up with a better term. Maybe <em>decoupled</em> is better? I’ll happily
take suggestions.</p>

<h2 id="so-what">So What?</h2>

<p>If the prospect of learning how builder crates work behind the scenes and doing some
metaprogramming in the process doesn’t already excite you, let me provide
some rationale for why the thing above could indeed be cool. Feel free to skip ahead.
I’ll concede right away that this is a pretty niche use case and that there are
other, saner ways of achieving a very similar effect. Also it is decidedly not my intention
to badmouth the crates above, I hope that much is clear by now.</p>

<p>At work I have a function with a rather nasty signature that takes a lot of 
parameters, some concrete types and some generic ones. It looks something like this:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">calculate</span><span class="o">&lt;</span><span class="n">M</span><span class="p">,</span><span class="n">R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">f32</span><span class="p">],</span> 
             <span class="n">param</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span> 
             <span class="n">mapping</span><span class="p">:</span> <span class="n">M</span><span class="p">,</span> 
             <span class="n">reduction</span><span class="p">:</span> <span class="n">R</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">f32</span> 
    <span class="k">where</span> <span class="n">M</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span>
          <span class="n">R</span><span class="p">:</span> <span class="n">Reduction</span> 
<span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div></div>

<p>This is still simplified substantially, but it captures the spirit. The non-generic parameters
are <code class="language-plaintext highlighter-rouge">data</code> and <code class="language-plaintext highlighter-rouge">param</code>. The generic parameters influence the logic which gets executed inside
the function. What I wanted to do, was to use <code class="language-plaintext highlighter-rouge">bon</code> –which allows to construct <a href="https://elastio.github.io/bon/guide/overview#builder-for-a-function">builders
for functions</a>–
to make my callsites more readable. It works by transforming the  functions to structs
with a <code class="language-plaintext highlighter-rouge">.call()</code> method behind the scenes. The <code class="language-plaintext highlighter-rouge">.call()</code> method is like the final
<code class="language-plaintext highlighter-rouge">.build()</code> call in the builder pattern, only that it calls the function with the 
finalized parameters instead of returning a struct instance. Brilliant. 
What I’d like to work is something like this<sup id="fnref:not-bon" role="doc-noteref"><a href="#fn:not-bon" class="footnote" rel="footnote">8</a></sup>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">calc</span> <span class="o">=</span> <span class="nn">CalculationBuilder</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
                        <span class="nf">.data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                        <span class="nf">.param</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
                        <span class="nf">.mapping</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>

<span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="k">if</span> <span class="n">fiddle</span> <span class="p">{</span> 
                <span class="c1">// fiddling: Fiddling</span>
                <span class="n">calc</span>
                    <span class="nf">.reduction</span><span class="p">(</span><span class="n">fiddling</span><span class="p">)</span>
                    <span class="nf">.call</span><span class="p">()</span>
             <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// frobnicate: Frobnication</span>
                <span class="n">calc</span>
                    <span class="nf">.reduction</span><span class="p">(</span><span class="n">frobnicate</span><span class="p">)</span>
                    <span class="nf">.call</span><span class="p">();</span>
             <span class="p">};</span>
</code></pre></div></div>

<p>I have run-time conditions that require the function to be called with the same
<code class="language-plaintext highlighter-rouge">data</code>, <code class="language-plaintext highlighter-rouge">param</code>, and <code class="language-plaintext highlighter-rouge">mapping</code> arguments, but with a <code class="language-plaintext highlighter-rouge">reduction</code> of different types.
If I try that, I’ll run into the same problem as above, because the builder enforces
the generics eagerly.</p>

<h1 id="goal-statement-lazy-generics">Goal Statement: Lazy Generics</h1>

<p>Now with all of the introductory stuff out of the way, let’s state the goals
and non-goals for this article:</p>

<ul>
  <li>We want to come up with a builder pattern that supports lazy
generics and explore the complexities that arise from it.</li>
  <li>We won’t go so far to actually write the procedural macro that generates
that builder. Instead we’ll write the builder by hand
and think through the steps that we’d take to automate this.</li>
</ul>

<p>We’ll stick with writing a builder for a struct because that’s the necessary 
first step to writing builders for functions<sup id="fnref:function-builders-where" role="doc-noteref"><a href="#fn:function-builders-where" class="footnote" rel="footnote">9</a></sup>. Meet
our struct:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Pod</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">S</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="p">,</span>
    <span class="n">T</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="o">+</span> <span class="n">MyTrait</span><span class="p">,</span>
<span class="p">{</span>
    <span class="n">field1</span><span class="p">:</span> <span class="nb">f32</span><span class="p">,</span>
    <span class="n">field2</span><span class="p">:</span> <span class="n">S</span><span class="p">,</span>
    <span class="n">field3</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">field4</span><span class="p">:</span> <span class="nn">T</span><span class="p">::</span><span class="n">AssocType</span><span class="p">,</span>
    <span class="n">field5</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// this is just a bogus</span>
<span class="c1">// trait that gives us </span>
<span class="c1">// associated types</span>
<span class="k">trait</span> <span class="n">MyTrait</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">AssocType</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’ll write a builder for that structure that allows lazy generics, similar
to what I presented above. There are a couple of things going on in this 
struct, so let’s examine it:</p>

<ul>
  <li>We have 3 generic parameters: the lifetime <code class="language-plaintext highlighter-rouge">'a</code> and the types <code class="language-plaintext highlighter-rouge">S</code> and <code class="language-plaintext highlighter-rouge">T</code>.</li>
  <li>We have a concrete type for <code class="language-plaintext highlighter-rouge">field1</code> thrown in for good measure.</li>
  <li>The generic parameters are constrained in a <code class="language-plaintext highlighter-rouge">where</code> clause<sup id="fnref:constraints" role="doc-noteref"><a href="#fn:constraints" class="footnote" rel="footnote">10</a></sup>.</li>
  <li><code class="language-plaintext highlighter-rouge">field2</code>, <code class="language-plaintext highlighter-rouge">field3</code> and <code class="language-plaintext highlighter-rouge">field5</code> have a <em>direct</em> dependency on one of
the generic type parameters.</li>
  <li><code class="language-plaintext highlighter-rouge">field4</code> <em>indirectly</em> depends on <code class="language-plaintext highlighter-rouge">T</code>, via an associated type.</li>
</ul>

<h2 id="interlude-direct-and-indirect-dependencies-on-types">Interlude: Direct and Indirect Dependencies on Types</h2>

<p>I should explain what I mean with <em>direct</em> and <em>indirect</em> dependencies on 
generic types. People more experienced in type-theory will probably scoff at me for
reinventing terms for things that already exist, but alas, I don’t know type
theory. I’m a mere programmer with a penchant for type system trickery. Do feel
free to leave a comment, though. I’m very happy to learn.</p>

<p>A <em>direct</em> dependency on a generic type <code class="language-plaintext highlighter-rouge">T</code> is when a field type can be deduced
from an assignment to the corresponding field. Let’s make this more concrete
by imagining you had a function that’s generic on <code class="language-plaintext highlighter-rouge">T</code> and takes the field type 
(which has some dependency on type <code class="language-plaintext highlighter-rouge">T</code>) as an argument:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">takes_field</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="cm">/*field type*/</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div>

<p>The question is now: can you write <code class="language-plaintext highlighter-rouge">takes_field(value)</code> without explicitly specifying
the generic type <code class="language-plaintext highlighter-rouge">T</code>? For example if the field type is <code class="language-plaintext highlighter-rouge">T</code>, <code class="language-plaintext highlighter-rouge">&amp;T</code>, <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>,
<code class="language-plaintext highlighter-rouge">Option&lt;Result&lt;T,()&gt;&gt;</code>, you definitely can! That’s a <em>direct</em> dependency of the
field type on the generic type <code class="language-plaintext highlighter-rouge">T</code>. However, if the field type is something like
<code class="language-plaintext highlighter-rouge">T::AssocType</code>, you can’t. One reason is that many types <code class="language-plaintext highlighter-rouge">T</code> or <code class="language-plaintext highlighter-rouge">U</code> could have
the same <code class="language-plaintext highlighter-rouge">AssocType</code>. Let’s call that an <em>indirect</em> dependency. Those are 
going to be important later.</p>

<h1 id="first-steps">First Steps</h1>

<p>Since we want to have a compile-time verified builder, we must write the builder
as a state machine, where the state is encoded in the type of the builder itself.
This is called the <em>typestate pattern</em> in Rust and I’m going to explain it in this
article. There’s also tons of information about it online. For each field, we want
to encode <em>via the type of the builder</em>, whether it has been set. We have five fields
in our structure, so we give our builder five generic types and five fields.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span><span class="n">F2</span><span class="p">,</span><span class="n">F3</span><span class="p">,</span><span class="n">F4</span><span class="p">,</span><span class="n">F5</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">field1</span><span class="p">:</span> <span class="n">F1</span><span class="p">,</span>
    <span class="n">field2</span><span class="p">:</span> <span class="n">F2</span><span class="p">,</span>
    <span class="n">field3</span><span class="p">:</span> <span class="n">F3</span><span class="p">,</span>
    <span class="n">field4</span><span class="p">:</span> <span class="n">F4</span><span class="p">,</span>
    <span class="n">field5</span><span class="p">:</span> <span class="n">F5</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that these parameters <code class="language-plaintext highlighter-rouge">F1</code>,…,<code class="language-plaintext highlighter-rouge">F5</code> are totally generic and have no relation
to the actual field types yet. This is essential for avoiding the problems with eager evaluation
of generics mentioned in the introduction. Not even the <code class="language-plaintext highlighter-rouge">field1</code> type is fixed to <code class="language-plaintext highlighter-rouge">f32</code>, although
we know that it can only be <code class="language-plaintext highlighter-rouge">f32</code>. However, we want to use the <em>types</em> to also 
encode whether a field has been set. For that, let’s define a couple of newtypes:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Default)]</span>
<span class="k">struct</span> <span class="n">Empty</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Assigned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">Empty</code> type indicates that a field has not been set, whereas the
<code class="language-plaintext highlighter-rouge">Assigned&lt;X&gt;</code> type indicates that it was assigned with a value of type <code class="language-plaintext highlighter-rouge">X</code>. Each
generic type of the builder starts at <code class="language-plaintext highlighter-rouge">Empty</code> and transitions to <code class="language-plaintext highlighter-rouge">Assigned&lt;...&gt;</code>
by invoking the corresponding setter function on the builder. Once a field is assigned,
it cannot be assigned again<sup id="fnref:assigned-once" role="doc-noteref"><a href="#fn:assigned-once" class="footnote" rel="footnote">11</a></sup>. That is the basic logic
we’ll implement in the rest of this article, but there are subtleties to consider
as we’ll see. Let’s also define a couple of traits to indicate if a type 
has a value or if it can be assigned still.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="n">Assignable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Assignable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Empty</span> <span class="p">{}</span>

<span class="k">trait</span> <span class="n">HasValue</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">ValueType</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">value</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">ValueType</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">HasValue</span> <span class="k">for</span> <span class="n">Assigned</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">ValueType</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

    <span class="k">fn</span> <span class="nf">value</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">ValueType</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Those two traits are not strictly necessary for the code in this article, because they
are only implemented by the <code class="language-plaintext highlighter-rouge">Empty</code> and <code class="language-plaintext highlighter-rouge">Assigned</code> types, respectively.
I’ll mention in this endnote<sup id="fnref:default-values" role="doc-noteref"><a href="#fn:default-values" class="footnote" rel="footnote">12</a></sup> how those traits help us to 
extend the presented method to allow for default values of fields.</p>

<h2 id="start-and-finish">Start and Finish</h2>

<p>Before we implement the state transitions, let’s see where the builder starts
and where it finishes. The builder starts with all fields empty, so we implement
a constructor for exactly that case.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">Empty</span><span class="p">,</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">Empty</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">field1</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
            <span class="n">field2</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
            <span class="n">field3</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
            <span class="n">field4</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
            <span class="n">field5</span><span class="p">:</span> <span class="nn">Default</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This allows us to call <code class="language-plaintext highlighter-rouge">PodBuilder::new()</code> to obtain a builder with all fields
empty. Note, that this builder is not coupled to the generics of the original
<code class="language-plaintext highlighter-rouge">Pod</code> struct. Note further, that this also <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1fd9cda519eaa0e952692a2dacf9725a">prevents us</a>
from exposing a <code class="language-plaintext highlighter-rouge">Pod::builder()</code> function to obtain the builder, which is the
–very elegant, but in this case also limiting– API that the other crates prefer.</p>

<p>The final stage of the builder is reached when all fields were assigned. Only
then do we allow the user to call the <code class="language-plaintext highlighter-rouge">build()</code> function. This function
consumes the builder and returns an instance of <code class="language-plaintext highlighter-rouge">Pod</code>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">F3</span><span class="p">,</span> <span class="n">F4</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">F3</span><span class="p">,</span> <span class="n">F4</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">build</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Pod</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="n">MyTrait</span><span class="p">,</span>
        <span class="n">S</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="p">,</span>
        <span class="n">F1</span><span class="p">:</span> <span class="n">HasValue</span><span class="o">&lt;</span><span class="n">ValueType</span> <span class="o">=</span> <span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">F2</span><span class="p">:</span> <span class="n">HasValue</span><span class="o">&lt;</span><span class="n">ValueType</span> <span class="o">=</span> <span class="n">S</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">F3</span><span class="p">:</span> <span class="n">HasValue</span><span class="o">&lt;</span><span class="n">ValueType</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">F4</span><span class="p">:</span> <span class="n">HasValue</span><span class="o">&lt;</span><span class="n">ValueType</span> <span class="o">=</span> <span class="nn">T</span><span class="p">::</span><span class="n">AssocType</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="n">F5</span><span class="p">:</span> <span class="n">HasValue</span><span class="o">&lt;</span><span class="n">ValueType</span> <span class="o">=</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="n">Pod</span> <span class="p">{</span>
            <span class="n">field1</span><span class="p">:</span> <span class="k">self</span><span class="py">.field1</span><span class="nf">.value</span><span class="p">(),</span>
            <span class="n">field2</span><span class="p">:</span> <span class="k">self</span><span class="py">.field2</span><span class="nf">.value</span><span class="p">(),</span>
            <span class="n">field3</span><span class="p">:</span> <span class="k">self</span><span class="py">.field3</span><span class="nf">.value</span><span class="p">(),</span>
            <span class="n">field4</span><span class="p">:</span> <span class="k">self</span><span class="py">.field4</span><span class="nf">.value</span><span class="p">(),</span>
            <span class="n">field5</span><span class="p">:</span> <span class="k">self</span><span class="py">.field5</span><span class="nf">.value</span><span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note, that the <code class="language-plaintext highlighter-rouge">build</code> function <em>does</em> include the generic types <code class="language-plaintext highlighter-rouge">'a</code>, <code class="language-plaintext highlighter-rouge">S</code>, and <code class="language-plaintext highlighter-rouge">T</code>
of <code class="language-plaintext highlighter-rouge">Pod</code>, that we had avoided before. It also includes all the trait bounds on
<code class="language-plaintext highlighter-rouge">S</code> and <code class="language-plaintext highlighter-rouge">T</code>. It allows us to call <code class="language-plaintext highlighter-rouge">builder.build()</code> on an instance of <code class="language-plaintext highlighter-rouge">PodBuilder</code>
if and only if it indicates –via its type signature– that all fields have been set.
Now let’s see how we actually implement state transitions to get us from
an all-empty builder to its final state one by one.</p>

<h2 id="setting-field-1-state-transitions-for-concrete-types">Setting Field 1: State Transitions for Concrete Types</h2>

<p><code class="language-plaintext highlighter-rouge">Pod::field1</code> is a concrete type, in this case <code class="language-plaintext highlighter-rouge">f32</code>. This is the simplest case
we can encounter when implementing state transitions. Whether <code class="language-plaintext highlighter-rouge">field1</code> is set in our
builder is encoded via the corresponding type <code class="language-plaintext highlighter-rouge">F1</code>. If this type implements the
<code class="language-plaintext highlighter-rouge">Assignable&lt;f32&gt;</code> trait (which in our case is just a more complicated way of 
saying that <code class="language-plaintext highlighter-rouge">F1</code> is <code class="language-plaintext highlighter-rouge">Empty</code>), then we want to consume our builder,
set the field, and return a new builder that encodes in its type that <code class="language-plaintext highlighter-rouge">field1</code>
was set.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">F3</span><span class="p">,</span> <span class="n">F4</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">F3</span><span class="p">,</span> <span class="n">F4</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">field1</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">field1</span><span class="p">:</span> <span class="nb">f32</span><span class="p">)</span> 
       <span class="k">-&gt;</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">Assigned</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">F3</span><span class="p">,</span> <span class="n">F4</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">F1</span><span class="p">:</span> <span class="n">Assignable</span><span class="o">&lt;</span><span class="nb">f32</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="n">PodBuilder</span> <span class="p">{</span>
            <span class="n">field1</span><span class="p">:</span> <span class="nf">Assigned</span><span class="p">(</span><span class="n">field1</span><span class="p">),</span>
            <span class="n">field2</span><span class="p">:</span> <span class="k">self</span><span class="py">.field2</span><span class="p">,</span>
            <span class="n">field3</span><span class="p">:</span> <span class="k">self</span><span class="py">.field3</span><span class="p">,</span>
            <span class="n">field4</span><span class="p">:</span> <span class="k">self</span><span class="py">.field4</span><span class="p">,</span>
            <span class="n">field5</span><span class="p">:</span> <span class="k">self</span><span class="py">.field5</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the type signature of the builder returned from this setter, <code class="language-plaintext highlighter-rouge">F1</code> is now of type <code class="language-plaintext highlighter-rouge">Assigned&lt;f32&gt;</code>
and carries the assigned value in <code class="language-plaintext highlighter-rouge">field1</code>. All other types <code class="language-plaintext highlighter-rouge">F2</code>,…,<code class="language-plaintext highlighter-rouge">F5</code>
just stay as they were and their values get moved into the new instance of
the builder. That allows us to call the setter function before or after any
of the other setter functions, the order of initialization does not matter.</p>

<h2 id="setting-field-2-simple-state-transitions-for-generic-types">Setting Field 2: Simple State Transitions for Generic Types</h2>

<p>Setting <code class="language-plaintext highlighter-rouge">field2</code> is almost as simple as setting <code class="language-plaintext highlighter-rouge">field1</code>, let’s see how its
done:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">F3</span><span class="p">,</span> <span class="n">F4</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">F3</span><span class="p">,</span> <span class="n">F4</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">field2</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">field2</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> 
       <span class="k">-&gt;</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">Assigned</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">F3</span><span class="p">,</span> <span class="n">F4</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">S</span><span class="p">:</span> <span class="n">Display</span><span class="p">,</span>
        <span class="n">F2</span><span class="p">:</span> <span class="n">Assignable</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="n">PodBuilder</span> <span class="p">{</span>
            <span class="n">field1</span><span class="p">:</span> <span class="k">self</span><span class="py">.field1</span><span class="p">,</span>
            <span class="n">field2</span><span class="p">:</span> <span class="nf">Assigned</span><span class="p">(</span><span class="n">field2</span><span class="p">),</span>
            <span class="n">field3</span><span class="p">:</span> <span class="k">self</span><span class="py">.field3</span><span class="p">,</span>
            <span class="n">field4</span><span class="p">:</span> <span class="k">self</span><span class="py">.field4</span><span class="p">,</span>
            <span class="n">field5</span><span class="p">:</span> <span class="k">self</span><span class="py">.field5</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The only thing that changed compared to above, is that our setter function
now accepts a generic type <code class="language-plaintext highlighter-rouge">S</code> and that we restrict <code class="language-plaintext highlighter-rouge">S</code> in a <code class="language-plaintext highlighter-rouge">where</code> clause
with the same restrictions as in the original <code class="language-plaintext highlighter-rouge">Pod</code> type. It’s really that
simple, but as we’ll see below it’s not always going to be this simple when
generic types are involved. It works like this here because of these
reasons:</p>

<ol>
  <li>the type of <code class="language-plaintext highlighter-rouge">Pod::field2</code> has a <em>direct</em> dependency on <code class="language-plaintext highlighter-rouge">S</code>. That means the type can be
deduced in the setter function <em>and</em></li>
  <li>the <code class="language-plaintext highlighter-rouge">where</code> clause restricting <code class="language-plaintext highlighter-rouge">S</code> has no dependencies on other types</li>
</ol>

<p>This gives us a taste of the complexities that we’ll be faced with in the
next sections, so let’s enjoy for a moment that it really can be this simple
sometimes before we move on.</p>

<h2 id="setting-fields-3-and-5-coupled-generic-types">Setting Fields 3 and 5: Coupled Generic Types</h2>

<p>Both the types of <code class="language-plaintext highlighter-rouge">Pod::field3</code> (which is <code class="language-plaintext highlighter-rouge">&amp;'a T</code>) and the type of <code class="language-plaintext highlighter-rouge">Pod::field5</code>
(which is <code class="language-plaintext highlighter-rouge">Option&lt;T&gt;</code>) have a <em>direct</em> dependency on <code class="language-plaintext highlighter-rouge">T</code>, which means <code class="language-plaintext highlighter-rouge">T</code> can be
deduced by assigning to either of these types. When I initially drafted this section
and the corresponding code, I had a whole spiel about how it was important to
check whether <code class="language-plaintext highlighter-rouge">field3</code> was already set when setting <code class="language-plaintext highlighter-rouge">field5</code> (and vice versa), to
help the type deduction. I’ve archived that code 
<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=ff4392d0e60e2c65e0d89e06dc946ad2">on the playground</a>,
but it was completely overblown. It turns out, if the field types
obey the conditions mentioned above, we can just treat them like we treated the
previous field. The correspoding setter implementations become:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">F3</span><span class="p">,</span> <span class="n">F4</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">F3</span><span class="p">,</span> <span class="n">F4</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="n">field3</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">field3</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">)</span> 
       <span class="k">-&gt;</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">Assigned</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">F4</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="n">MyTrait</span><span class="p">,</span>
        <span class="n">F3</span><span class="p">:</span> <span class="n">Assignable</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="n">PodBuilder</span> <span class="p">{</span>
            <span class="n">field1</span><span class="p">:</span> <span class="k">self</span><span class="py">.field1</span><span class="p">,</span>
            <span class="n">field2</span><span class="p">:</span> <span class="k">self</span><span class="py">.field2</span><span class="p">,</span>
            <span class="n">field3</span><span class="p">:</span> <span class="nf">Assigned</span><span class="p">(</span><span class="n">field3</span><span class="p">),</span>
            <span class="n">field4</span><span class="p">:</span> <span class="k">self</span><span class="py">.field4</span><span class="p">,</span>
            <span class="n">field5</span><span class="p">:</span> <span class="k">self</span><span class="py">.field5</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">field5</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">field5</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> 
       <span class="k">-&gt;</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">F3</span><span class="p">,</span> <span class="n">F4</span><span class="p">,</span> <span class="n">Assigned</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="n">MyTrait</span><span class="p">,</span>
        <span class="n">F5</span><span class="p">:</span> <span class="n">Assignable</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="n">PodBuilder</span> <span class="p">{</span>
            <span class="n">field1</span><span class="p">:</span> <span class="k">self</span><span class="py">.field1</span><span class="p">,</span>
            <span class="n">field2</span><span class="p">:</span> <span class="k">self</span><span class="py">.field2</span><span class="p">,</span>
            <span class="n">field3</span><span class="p">:</span> <span class="k">self</span><span class="py">.field3</span><span class="p">,</span>
            <span class="n">field4</span><span class="p">:</span> <span class="k">self</span><span class="py">.field4</span><span class="p">,</span>
            <span class="n">field5</span><span class="p">:</span> <span class="nf">Assigned</span><span class="p">(</span><span class="n">field5</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>It’s just the same as in the section above, there’s not much more to it than that.
 A note on type deduction: the final call to <code class="language-plaintext highlighter-rouge">build()</code> forces that <code class="language-plaintext highlighter-rouge">T</code> is deduced
as one unified type. So, as long as we end our builder
chains –including the ones that are forked between branches– with a call to
<code class="language-plaintext highlighter-rouge">build()</code>, the type system is smart enough to conclude that the assigned types
are supposed to be the same.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">builder</span> <span class="o">=</span> <span class="nn">PodBuilder</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
    <span class="nf">.field5</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="s">"hi"</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="nf">.field3</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">())</span>
<span class="c1">// -- other field assignments, possibly branches --</span>
<span class="c1">// let builder = ...</span>

<span class="c1">// assuming this is now a finished builder</span>
<span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">builder</span><span class="nf">.build</span><span class="p">();</span>

</code></pre></div></div>

<p>We’ll have all the sweet type deduction we come to expect. The important thing
is that the builder chains gets finished with the <code class="language-plaintext highlighter-rouge">build()</code> method. However, that’s
guaranteed to happen, because why else would you have a builder in the first place…?</p>

<h2 id="setting-field-4-field-types-with-indirect-dependencies-on-generic-types">Setting Field 4: Field Types with Indirect Dependencies on Generic Types</h2>

<p>The type of <code class="language-plaintext highlighter-rouge">Pod::field4</code> is <code class="language-plaintext highlighter-rouge">T::AssocType</code>, which means it depends on the
generic type <code class="language-plaintext highlighter-rouge">T</code> indirectly. We can’t deduce <code class="language-plaintext highlighter-rouge">T</code> from assigning to <code class="language-plaintext highlighter-rouge">field4</code>.
Somehow, we have to know the type <code class="language-plaintext highlighter-rouge">T</code>. We could force the user to explicitly
tell us, but I don’t like that so much. We could also expose
the setter for <code class="language-plaintext highlighter-rouge">field4</code> only if we know <code class="language-plaintext highlighter-rouge">T</code> already, which is the option
that I went with. That is the case when <code class="language-plaintext highlighter-rouge">field3</code> or
<code class="language-plaintext highlighter-rouge">field5</code> (or both) have already been assigned.</p>

<h3 id="excursion-dependency-graphs">Excursion: Dependency Graphs</h3>

<p>Since the ultimate goal (not in this article, but eventually) is to implement this
into a derive macro, let’s go through this analysis a little more formally. Let’s
visualize the direct and indirect dependencies of the builder types (lower row)
and the structure generic types (upper row).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Pod:              S    'a     T
                  |    |     /|\
                  |    |    / | \
                  d    d   d  i  d    
                  |    |  /   |   \
                  |    | /    |    \
Builder:   F1     F2   F3     F4   F5
</code></pre></div></div>

<p>The generic types of the builder <code class="language-plaintext highlighter-rouge">F1</code>,…,<code class="language-plaintext highlighter-rouge">F5</code> have a one-to-one correspondence
with the builder fields <code class="language-plaintext highlighter-rouge">PodBuilder::field1</code>,…<code class="language-plaintext highlighter-rouge">Podbuilder::field5</code>.
Their dependency on the generic types <code class="language-plaintext highlighter-rouge">'a</code>, <code class="language-plaintext highlighter-rouge">S</code>, and <code class="language-plaintext highlighter-rouge">T</code> is via the field types
<code class="language-plaintext highlighter-rouge">Pod::field1</code>,…,<code class="language-plaintext highlighter-rouge">Pod::field5</code> of the original structure. Here, a line with an
<code class="language-plaintext highlighter-rouge">i</code> is an <em>indirect</em> dependency and a line with a <code class="language-plaintext highlighter-rouge">d</code> is a <em>direct</em> dependency.
Here we have a pretty simple (not fully connected) dependency graph. We are
trying to set <code class="language-plaintext highlighter-rouge">field4</code>, which is associated with type <code class="language-plaintext highlighter-rouge">F4</code>. So we look at the graph
and collect all the original generic types on whom <code class="language-plaintext highlighter-rouge">F4</code> depends <em>indirectly</em>. Here, 
that’s just <code class="language-plaintext highlighter-rouge">T</code>, which only has other <em>direct</em> dependencies. So we go
ahead and collect those, in our case
<code class="language-plaintext highlighter-rouge">F3</code> and <code class="language-plaintext highlighter-rouge">F5</code>. Now we know that it’s a prerequisite that either one (or both)
of the generic arguments <code class="language-plaintext highlighter-rouge">F3</code>, <code class="language-plaintext highlighter-rouge">F5</code> have their corresponding value assigned, before
we can assign to the <code class="language-plaintext highlighter-rouge">field4</code> associated with <code class="language-plaintext highlighter-rouge">F4</code>.</p>

<h3 id="implementing-setters-that-require-other-fields-to-be-set">Implementing Setters that Require Other Fields to be Set</h3>

<p>Let’s now see how to implement the setter for <code class="language-plaintext highlighter-rouge">field4</code> only if <code class="language-plaintext highlighter-rouge">F3</code> and/or <code class="language-plaintext highlighter-rouge">F5</code>
were set. There are three combinations for (<code class="language-plaintext highlighter-rouge">F3</code>,<code class="language-plaintext highlighter-rouge">F5</code>) where we want to allow the
setter to be invoked, which are (Empty, Assigned), (Assigned, Empty), and (Assigned, Assigned). In
a procedural macro, I’d probably output dedicated code for all of those 
combinatorial cases. However, for this particular application we can see that
we can collapse (for example) the last two cases into a single <code class="language-plaintext highlighter-rouge">impl</code> block.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// covers the case (F3,F5) = (Empty,Assigned)</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="o">&gt;</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">Assigned</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="n">MyTrait</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">field4</span><span class="p">(</span>
        <span class="k">self</span><span class="p">,</span>
        <span class="n">field4</span><span class="p">:</span> <span class="nn">T</span><span class="p">::</span><span class="n">AssocType</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">Assigned</span><span class="o">&lt;</span><span class="nn">T</span><span class="p">::</span><span class="n">AssocType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Assigned</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
        <span class="n">PodBuilder</span> <span class="p">{</span>
            <span class="n">field1</span><span class="p">:</span> <span class="k">self</span><span class="py">.field1</span><span class="p">,</span>
            <span class="n">field2</span><span class="p">:</span> <span class="k">self</span><span class="py">.field2</span><span class="p">,</span>
            <span class="n">field3</span><span class="p">:</span> <span class="n">Empty</span><span class="p">,</span>
            <span class="n">field4</span><span class="p">:</span> <span class="nf">Assigned</span><span class="p">(</span><span class="n">field4</span><span class="p">),</span>
            <span class="n">field5</span><span class="p">:</span> <span class="k">self</span><span class="py">.field5</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// covers the cases (F3,F5) = (Assigned, Empty) or (Assigned, Assigned)</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">Assigned</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="n">MyTrait</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">field4</span><span class="p">(</span>
        <span class="k">self</span><span class="p">,</span>
        <span class="n">field4</span><span class="p">:</span> <span class="nn">T</span><span class="p">::</span><span class="n">AssocType</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="n">PodBuilder</span><span class="o">&lt;</span><span class="n">F1</span><span class="p">,</span> <span class="n">F2</span><span class="p">,</span> <span class="n">Assigned</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Assigned</span><span class="o">&lt;</span><span class="nn">T</span><span class="p">::</span><span class="n">AssocType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">F5</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">PodBuilder</span> <span class="p">{</span>
            <span class="n">field1</span><span class="p">:</span> <span class="k">self</span><span class="py">.field1</span><span class="p">,</span>
            <span class="n">field2</span><span class="p">:</span> <span class="k">self</span><span class="py">.field2</span><span class="p">,</span>
            <span class="n">field3</span><span class="p">:</span> <span class="k">self</span><span class="py">.field3</span><span class="p">,</span>
            <span class="n">field4</span><span class="p">:</span> <span class="nf">Assigned</span><span class="p">(</span><span class="n">field4</span><span class="p">),</span>
            <span class="n">field5</span><span class="p">:</span> <span class="k">self</span><span class="py">.field5</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And just like that, we have finished our implementation of the builder. Let’s see
what we can do with it.</p>

<h1 id="using-the-builder-with-lazy-generics">Using the Builder with Lazy Generics</h1>

<p>I’ve put <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=579320ddbe4c8cfd95f4cdbb95b431dc">the code on the playground</a>,
so please do play with it. Of course, the builder supports the most basic
application, which is constructing a <code class="language-plaintext highlighter-rouge">Pod</code> from one complete chain:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">pod</span> <span class="o">=</span> <span class="nn">PodBuilder</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
    <span class="nf">.field2</span><span class="p">(</span><span class="mf">1f64</span><span class="p">)</span>
    <span class="nf">.field1</span><span class="p">(</span><span class="mf">337.</span><span class="p">)</span>
    <span class="nf">.field5</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="s">"hi"</span><span class="nf">.into</span><span class="p">()))</span>
    <span class="nf">.field3</span><span class="p">(</span><span class="o">&amp;</span><span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">())</span>
    <span class="nf">.field4</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nf">.build</span><span class="p">();</span>
</code></pre></div></div>

<p>But that’s what all the other builder crates can do as well, so let’s look
at some lazy generics:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">MyTrait</span> <span class="k">for</span> <span class="nb">i32</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">AssocType</span> <span class="o">=</span> <span class="nb">f32</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">MyTrait</span> <span class="k">for</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">AssocType</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">foo</span><span class="p">(</span><span class="n">cond</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">othercond</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">builder</span> <span class="o">=</span> <span class="nn">PodBuilder</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span><span class="nf">.field1</span><span class="p">(</span><span class="mf">1.</span><span class="p">);</span>
    <span class="k">if</span> <span class="n">cond</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">builder</span> <span class="o">=</span> <span class="n">builder</span>
            <span class="nf">.field2</span><span class="p">(</span><span class="s">"foo"</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">othercond</span> <span class="p">{</span>
            <span class="c1">// pod: Pod&lt;&amp;str,String&gt;</span>
            <span class="k">let</span> <span class="n">pod</span> <span class="o">=</span> <span class="n">builder</span>
                <span class="nf">.field5</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span>
                <span class="nf">.field4</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="nf">.field3</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span>
                <span class="nf">.build</span><span class="p">();</span>
            <span class="c1">// use pod...</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// pod: Pod&lt;&amp;str,i32&gt;</span>
            <span class="k">let</span> <span class="n">pod</span> <span class="o">=</span> <span class="n">builder</span>
                <span class="nf">.field5</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="err">.</span>
                <span class="nf">.field4</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>
                <span class="nf">.field3</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">)</span>
                <span class="nf">.build</span><span class="p">();</span>
            <span class="c1">// use pod...</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// pod: Pod&lt;i32, String&gt;</span>
        <span class="k">let</span> <span class="n">pod</span> <span class="o">=</span> <span class="n">builder</span>
            <span class="nf">.field3</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span>
            <span class="nf">.field5</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="s">"hi"</span><span class="nf">.into</span><span class="p">()))</span>
            <span class="nf">.field2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="nf">.field4</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="nf">.build</span><span class="p">();</span>
        <span class="c1">// use pod...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It shows that we can fork the builder based on runtime conditions without
locking in unassigned types across forks. The builder becomes a stemcell with
lazy generics.</p>

<h1 id="outlook-function-builders-and-where-clauses">Outlook: Function Builders and Where Clauses</h1>

<p>This has been a long and complicated article, but allow me some final remarks. I think
the most interesting application of builders with lazy generics, is the possibility
of using them to create builders for generic functions.
In principle, there’s nothing stopping us from doing that now, based on what
we did. There are two problems that we’ll run into:</p>

<ol>
  <li>Generic types which are not part of the function arguments or not
deducable via the function argument types.</li>
  <li>More complicated trait bounds, such as the circular bounds <code class="language-plaintext highlighter-rouge">where T: Add&lt;S&gt;, S: Sub&lt;T&gt;</code>.</li>
</ol>

<p>We can encounter both problems<sup id="fnref:phantom-data" role="doc-noteref"><a href="#fn:phantom-data" class="footnote" rel="footnote">13</a></sup> in structs as well. I think the first
one is easy to solve, since we can just have our builder’s constructor force the user to specify those
types that cannot be deduced. The second problem is a bit trickier:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">do_something</span><span class="p">(</span><span class="n">first</span><span class="p">:</span> <span class="n">S</span><span class="p">,</span> <span class="n">second</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> 
    <span class="k">where</span> <span class="n">S</span><span class="p">:</span> <span class="nb">Sub</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
          <span class="n">T</span><span class="p">:</span> <span class="nb">Add</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nb">Ord</span><span class="p">,</span>
          
<span class="p">{</span><span class="o">...</span><span class="p">}</span>
</code></pre></div></div>

<p>In the setters above, we just copied all the trait bounds of the particular generic type.
That won’t work anymore because we can’t name <code class="language-plaintext highlighter-rouge">T</code> in the setter for <code class="language-plaintext highlighter-rouge">S</code>,
except if we require the type <code class="language-plaintext highlighter-rouge">T</code> to be known. However, we’d then 
also have to require the type <code class="language-plaintext highlighter-rouge">S</code> to be known in our setter for <code class="language-plaintext highlighter-rouge">T</code>. 
We could then never actually set <em>any</em> of these fields due to the circular dependency.
But I <em>think</em> the solution is easier than it looks at first: we should just be
able to skip all the restrictions that depend on generic types other the ones
named in the field type associated with the setter. That means in the setter for <code class="language-plaintext highlighter-rouge">first</code>
we just restrict <code class="language-plaintext highlighter-rouge">S</code> on <code class="language-plaintext highlighter-rouge">Clone</code> and in the setter for <code class="language-plaintext highlighter-rouge">second</code> we restrict
<code class="language-plaintext highlighter-rouge">T</code> only on <code class="language-plaintext highlighter-rouge">Ord</code>. In the final <code class="language-plaintext highlighter-rouge">build()</code> call, we can then enforce all the
restrictions again, because we can name all of the types.</p>

<h1 id="final-words">Final Words</h1>

<p>If you read this far, cheers to you. There are more things that I’d like to say
about this method, but this post is already very long. So I’ll just leave it at
that. I don’t claim that all builders need to support the lazy generics as presented
here. I just hadn’t seen it anywhere else, maybe it’s out there and I did not
look hard enough. I’m very happy to engage in the comments at the end of this
article.</p>

<h1 id="endnotes">Endnotes</h1>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:runtime-builders" role="doc-endnote">
      <p>There’s also the excellent and venerable <a href="https://crates.io/crates/derive_builder"><code class="language-plaintext highlighter-rouge">derive_builder</code></a> (ver <code class="language-plaintext highlighter-rouge">0.20.1</code>), which does all validations (including forgotten fields) at run time. The problems with generics addressed in this article also apply to this crate. <a href="#fnref:runtime-builders" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:bon-core" role="doc-endnote">
      <p>The <code class="language-plaintext highlighter-rouge">bon</code> crate allows to create builders not only for structs but also e.g. for functions. However, this functionality internally transforms the function into a structure with a <code class="language-plaintext highlighter-rouge">.call()</code> method. The function arguments are made into fields of the generated structure. Then, a builder for this new struct is generated and thus it has the same limitations as the builders that are applied directly to structures. <a href="#fnref:bon-core" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:typed-builder-generics" role="doc-endnote">
      <p>Except the <code class="language-plaintext highlighter-rouge">typestate_builder</code> crate which, at the time of writing, still struggles with generics. At least when we use the intended API. It can be hacked to make this and the simple lazy generic example work, see <a href="https://github.com/geo-ant/builder-experiments/blob/main/src/crosschecks.rs">here</a> <a href="#fnref:typed-builder-generics" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:builder-capabilities" role="doc-endnote">
      <p>Examples including: optional fields, <code class="language-plaintext highlighter-rouge">Into</code>-conversions, default parameters and much more, depending on the crate. <a href="https://elastio.github.io/bon/guide/alternatives">Here</a> is a great overview by the <code class="language-plaintext highlighter-rouge">bon</code> maintainers. <a href="#fnref:builder-capabilities" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:tried-this" role="doc-endnote">
      <p>I’ve of course tried the code in question with all the mentioned crates and verified that it fails to compile. I’ve also looked at the macro expansion, which makes me pretty confident that this is not something that these crates <em>can</em> do. However, I might still have gotten things wrong or missed additional options and I am happy to be corrected. See <a href="https://github.com/geo-ant/builder-experiments/blob/main/src/crosschecks.rs">here</a> to see what I did. <a href="#fnref:tried-this" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:state-params" role="doc-endnote">
      <p>The exact form of the other generic parameters varies slightly between crates, but the principle is always the same. Again, bear with me… we’ll go into the details later. <a href="#fnref:state-params" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:typestate-builder" role="doc-endnote">
      <p>This is where the <code class="language-plaintext highlighter-rouge">typestate_builder</code> crate does something different. It still runs into the trap of exposing the <code class="language-plaintext highlighter-rouge">Foo::builder()</code> function as the only way to expose a builder. That is the reason why this example will fail. But it can be tricked into providing an empty builder and then we can actually make this example compile. However, this crate is currently not able to work with the more complex example that I’ll present in the sections below. <a href="#fnref:typestate-builder" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:not-bon" role="doc-endnote">
      <p>This is less elegant than <a href="https://elastio.github.io/bon/guide/overview#builder-for-a-function">how it would actually look</a> in <code class="language-plaintext highlighter-rouge">bon</code>. But for the sake of this article, it’s better like this, since this looks more similar to the builder pattern in the intro section. <a href="#fnref:not-bon" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:function-builders-where" role="doc-endnote">
      <p>Function builders don’t necessarily follow trivially, because <code class="language-plaintext highlighter-rouge">where</code> clauses for generics in functions typically involve constraints that are not essential to construct the arguments, but to perform the logic of the function (think <code class="language-plaintext highlighter-rouge">T: Add&lt;U::AssocType&gt;</code>). In this case we’d like a way to specify two where clauses: one with the essential requirements that enable us to construct the argument types without compilation errors. This where clause would go on the builder struct. And an additional where clause for all the logic requirements that the function needs. This (plus the essential where clause) would then be stuck on the <code class="language-plaintext highlighter-rouge">.call()</code> method. We could achieve this by allowing attribute macros that capture the essential <code class="language-plaintext highlighter-rouge">where</code> clause, like <code class="language-plaintext highlighter-rouge">#[essential(where T: Scalar)]</code> and then the stuff that is not essential for constructing the types could go into the actual <code class="language-plaintext highlighter-rouge">where</code> clause of the function. Our procedural macro would then take care of splitting and combining the where clauses as necessary. <a href="#fnref:function-builders-where" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:constraints" role="doc-endnote">
      <p>When writing procedural macros, it’s important to keep in mind that <code class="language-plaintext highlighter-rouge">where</code> clauses are not the only places where constraints can be places on parameters. To gather all the constraints one has to parse the generic types in the struct definition as well. <a href="#fnref:constraints" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:assigned-once" role="doc-endnote">
      <p>This is a choice on my part, but it’s something that the other builders to as well. We could also modify the state machine pattern to allow overwriting, but I feel it’s more likely an indication of an accident on the user’s part. <a href="#fnref:assigned-once" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:default-values" role="doc-endnote">
      <p>At least for non-generic field types it’s easy to allow for default values (it gets more complicated if the field type is generic). What we do is introduce another type <code class="language-plaintext highlighter-rouge">WithDefault&lt;T&gt;(T)</code> that implements <code class="language-plaintext highlighter-rouge">Assignable&lt;T&gt;</code>, but also <code class="language-plaintext highlighter-rouge">HasValue&lt;ValueType = T&gt;</code>. For fields where we want to allow default values in case the user does not set one, we start with a <code class="language-plaintext highlighter-rouge">WithDefault&lt;T&gt;</code> containing the default value rather than <code class="language-plaintext highlighter-rouge">Empty</code>. If we assign to a <code class="language-plaintext highlighter-rouge">WithDefault</code>, then it transitions to <code class="language-plaintext highlighter-rouge">Assigned</code>. But even if we don’t, the builder will allow to call <code class="language-plaintext highlighter-rouge">build</code> because <code class="language-plaintext highlighter-rouge">WithDefault</code> also implements <code class="language-plaintext highlighter-rouge">HasValue</code>. <a href="#fnref:default-values" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:phantom-data" role="doc-endnote">
      <p>In structs we can’t have types that aren’t part of the fields at all. We’ll at least have phantom fields, but in practice those should not expose setters, but instead force the user to specify the types explicitly. <a href="#fnref:phantom-data" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>


    <div>
      <!-- <a href="https://ko-fi.com/geoant" target="_blank" title="Buy me a coffee :)">
          <img src="https://raw.githubusercontent.com/geo-ant/user-content/refs/heads/main/ko-fi-support-blue.svg" 
               alt="Banner Image" style="max-width: 190px; height: auto; margin-right: 20px;">
      </a> -->
    <div>
  </div>
    
  <div>
    
    
      <a href="/blog/tags/#design-patterns" class="post-tag">design-patterns</a>
    
      <a href="/blog/tags/#generics" class="post-tag">generics</a>
    
      <a href="/blog/tags/#metaprogramming" class="post-tag">metaprogramming</a>
    
      <a href="/blog/tags/#rust" class="post-tag">rust</a>
    
  </div>

  <div>
  
    <script src="  https://unpkg.com/showdown/dist/showdown.min.js"></script>
<script>
const GH_API_URL = 'https://api.github.com/repos/statmlben/stackseparating/issues/73/comments'; // ?client_id=&client_secret=

let request = new XMLHttpRequest();
request.open( 'GET', GH_API_URL, true );
request.onload = function() {
	if ( this.status >= 200 && this.status < 400 ) {
		let response = JSON.parse( this.response );

		for ( var i = 0; i < response.length; i++ ) {
			document.getElementById( 'gh-comments-list' ).appendChild( createCommentEl( response[ i ] ) );
		}

		if ( 0 === response.length ) {
			document.getElementById( 'no-comments-found' ).style.display = 'block';
		}
	} else {
		console.error( this );
	}
};

function createCommentEl( response ) {
	let user = document.createElement( 'a' );
	user.setAttribute( 'href', response.user.url.replace( 'api.github.com/users', 'github.com' ) );
	user.classList.add( 'user' );

	//let userAvatar = document.createElement( 'img' );
	let userAvatar = document.createElement( 'a' );
	userAvatar.classList.add( 'avatar' );
	userAvatar.innerHTML =  response.user.login +':';
	//userAvatar.style.fontStyle = "italic";

	user.appendChild( userAvatar );

	let commentLink = document.createElement( 'a' );
	commentLink.setAttribute( 'href', response.html_url );
	commentLink.classList.add( 'comment-url' );
	commentLink.innerHTML = '(#' + response.id + ' - ' + response.created_at+')';
	commentLink.style.fontSize = "small";

	let commentContents = document.createElement( 'div' );
	commentContents.classList.add( 'comment-content' );
	commentContents.innerHTML = response.body;
	// Progressive enhancement.
	if ( window.showdown ) {
		let converter = new showdown.Converter();
		commentContents.innerHTML = converter.makeHtml( response.body );
	}

	let comment = document.createElement( 'li' );
	comment.setAttribute( 'data-created', response.created_at );
	comment.setAttribute( 'data-author-avatar', response.user.avatar_url );
	comment.setAttribute( 'data-user-url', response.user.url );

	comment.appendChild( user );
	comment.appendChild( commentContents );
	comment.appendChild( commentLink );

	return comment;
}
request.send();
</script>


<div class="github-comments">
	<h1>Comments</h1>
	<ul id="gh-comments-list"></ul>
	<p id="no-comments-found">You can comment on this post using your GitHub account.</p>
	<p id="leave-a-comment">Join the discussion for this article on <a href="https://github.com/statmlben/stackseparating/issues/73">this ticket</a>. Comments appear on this page instantly.</p>
</div>

  

  
  </div>

</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:bendai@cuhk.edu.hk"><i class="svg-icon email"></i></a>


<a href="https://github.com/statmlben"><i class="svg-icon github"></i></a>



<!-- <a href="/blog/feed.xml"><i class="svg-icon rss"></i></a> -->




        </footer>
      </div>
    </div>

    
<script type="text/javascript">
  /**
 * AnchorJS - v4.1.0 - 2017-09-20
 * https://github.com/bryanbraun/anchorjs
 * Copyright (c) 2017 Bryan Braun; Licensed MIT
 */
!function(A,e){"use strict";"function"==typeof define&&define.amd?define([],e):"object"==typeof module&&module.exports?module.exports=e():(A.AnchorJS=e(),A.anchors=new A.AnchorJS)}(this,function(){"use strict";return function(A){function e(A){A.icon=A.hasOwnProperty("icon")?A.icon:"",A.visible=A.hasOwnProperty("visible")?A.visible:"hover",A.placement=A.hasOwnProperty("placement")?A.placement:"right",A.ariaLabel=A.hasOwnProperty("ariaLabel")?A.ariaLabel:"Anchor",A.class=A.hasOwnProperty("class")?A.class:"",A.truncate=A.hasOwnProperty("truncate")?Math.floor(A.truncate):64}function t(A){var e;if("string"==typeof A||A instanceof String)e=[].slice.call(document.querySelectorAll(A));else{if(!(Array.isArray(A)||A instanceof NodeList))throw new Error("The selector provided to AnchorJS was invalid.");e=[].slice.call(A)}return e}function i(){if(null===document.head.querySelector("style.anchorjs")){var A,e=document.createElement("style");e.className="anchorjs",e.appendChild(document.createTextNode("")),void 0===(A=document.head.querySelector('[rel="stylesheet"], style'))?document.head.appendChild(e):document.head.insertBefore(e,A),e.sheet.insertRule(" .anchorjs-link {   opacity: 0;   text-decoration: none;   -webkit-font-smoothing: antialiased;   -moz-osx-font-smoothing: grayscale; }",e.sheet.cssRules.length),e.sheet.insertRule(" *:hover > .anchorjs-link, .anchorjs-link:focus  {   opacity: 1; }",e.sheet.cssRules.length),e.sheet.insertRule(" [data-anchorjs-icon]::after {   content: attr(data-anchorjs-icon); }",e.sheet.cssRules.length),e.sheet.insertRule(' @font-face {   font-family: "anchorjs-icons";   src: url(data:n/a;base64,AAEAAAALAIAAAwAwT1MvMg8yG2cAAAE4AAAAYGNtYXDp3gC3AAABpAAAAExnYXNwAAAAEAAAA9wAAAAIZ2x5ZlQCcfwAAAH4AAABCGhlYWQHFvHyAAAAvAAAADZoaGVhBnACFwAAAPQAAAAkaG10eASAADEAAAGYAAAADGxvY2EACACEAAAB8AAAAAhtYXhwAAYAVwAAARgAAAAgbmFtZQGOH9cAAAMAAAAAunBvc3QAAwAAAAADvAAAACAAAQAAAAEAAHzE2p9fDzz1AAkEAAAAAADRecUWAAAAANQA6R8AAAAAAoACwAAAAAgAAgAAAAAAAAABAAADwP/AAAACgAAA/9MCrQABAAAAAAAAAAAAAAAAAAAAAwABAAAAAwBVAAIAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMCQAGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAg//0DwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAAIAAAACgAAxAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADAAAAAIAAgAAgAAACDpy//9//8AAAAg6cv//f///+EWNwADAAEAAAAAAAAAAAAAAAAACACEAAEAAAAAAAAAAAAAAAAxAAACAAQARAKAAsAAKwBUAAABIiYnJjQ3NzY2MzIWFxYUBwcGIicmNDc3NjQnJiYjIgYHBwYUFxYUBwYGIwciJicmNDc3NjIXFhQHBwYUFxYWMzI2Nzc2NCcmNDc2MhcWFAcHBgYjARQGDAUtLXoWOR8fORYtLTgKGwoKCjgaGg0gEhIgDXoaGgkJBQwHdR85Fi0tOAobCgoKOBoaDSASEiANehoaCQkKGwotLXoWOR8BMwUFLYEuehYXFxYugC44CQkKGwo4GkoaDQ0NDXoaShoKGwoFBe8XFi6ALjgJCQobCjgaShoNDQ0NehpKGgobCgoKLYEuehYXAAAADACWAAEAAAAAAAEACAAAAAEAAAAAAAIAAwAIAAEAAAAAAAMACAAAAAEAAAAAAAQACAAAAAEAAAAAAAUAAQALAAEAAAAAAAYACAAAAAMAAQQJAAEAEAAMAAMAAQQJAAIABgAcAAMAAQQJAAMAEAAMAAMAAQQJAAQAEAAMAAMAAQQJAAUAAgAiAAMAAQQJAAYAEAAMYW5jaG9yanM0MDBAAGEAbgBjAGgAbwByAGoAcwA0ADAAMABAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAH//wAP) format("truetype"); }',e.sheet.cssRules.length)}}this.options=A||{},this.elements=[],e(this.options),this.isTouchDevice=function(){return!!("ontouchstart"in window||window.DocumentTouch&&document instanceof DocumentTouch)},this.add=function(A){var n,o,s,a,r,c,h,l,u,d,f,p=[];if(e(this.options),"touch"===(f=this.options.visible)&&(f=this.isTouchDevice()?"always":"hover"),A||(A="h2, h3, h4, h5, h6"),0===(n=t(A)).length)return this;for(i(),o=document.querySelectorAll("[id]"),s=[].map.call(o,function(A){return A.id}),r=0;r<n.length;r++)if(this.hasAnchorJSLink(n[r]))p.push(r);else{if(n[r].hasAttribute("id"))a=n[r].getAttribute("id");else if(n[r].hasAttribute("data-anchor-id"))a=n[r].getAttribute("data-anchor-id");else{u=l=this.urlify(n[r].textContent),h=0;do{void 0!==c&&(u=l+"-"+h),c=s.indexOf(u),h+=1}while(-1!==c);c=void 0,s.push(u),n[r].setAttribute("id",u),a=u}a.replace(/-/g," "),(d=document.createElement("a")).className="anchorjs-link "+this.options.class,d.href="#"+a,d.setAttribute("aria-label",this.options.ariaLabel),d.setAttribute("data-anchorjs-icon",this.options.icon),"always"===f&&(d.style.opacity="1"),""===this.options.icon&&(d.style.font="1em/1 anchorjs-icons","left"===this.options.placement&&(d.style.lineHeight="inherit")),"left"===this.options.placement?(d.style.position="absolute",d.style.marginLeft="-1em",d.style.paddingRight="0.5em",n[r].insertBefore(d,n[r].firstChild)):(d.style.paddingLeft="0.375em",n[r].appendChild(d))}for(r=0;r<p.length;r++)n.splice(p[r]-r,1);return this.elements=this.elements.concat(n),this},this.remove=function(A){for(var e,i,n=t(A),o=0;o<n.length;o++)(i=n[o].querySelector(".anchorjs-link"))&&(-1!==(e=this.elements.indexOf(n[o]))&&this.elements.splice(e,1),n[o].removeChild(i));return this},this.removeAll=function(){this.remove(this.elements)},this.urlify=function(A){var t=/[^A-Za-z0-9._-]/g;return this.options.truncate||e(this.options),A.trim().replace(/\'/gi,"").replace(t,"-").replace(/-{2,}/g,"-").substring(0,this.options.truncate).replace(/^-+|-+$/gm,"").toLowerCase()},this.hasAnchorJSLink=function(A){var e=A.firstChild&&(" "+A.firstChild.className+" ").indexOf(" anchorjs-link ")>-1,t=A.lastChild&&(" "+A.lastChild.className+" ").indexOf(" anchorjs-link ")>-1;return e||t||!1}}});

  new AnchorJS({
    placement: 'left',
    truncate: 32,
    visible: 'hover',
  }).add('h2');

  new AnchorJS({
    icon: '¶',
    placement: 'left',
    truncate: 32,
    visible: 'hover',
  }).add('p');
</script>


  </body>
</html>
